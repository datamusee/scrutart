<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphe RDF</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-zoom@3"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #graph-container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }
        button {
            margin: 0 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="zoom-in">+</button>
        <button id="zoom-out">-</button>
        <button id="reset-zoom">RÃ©initialiser</button>
        <button id="back-button" onclick="window.history.back()">Retour</button>
    </div>
    <div id="graph-container"></div>

    <script>
        const data = JSON.parse('{{ data|tojson|safe }}');
        const mode = '{{ mode }}';
        renderFullscreenGraph(data, mode);

        function renderFullscreenGraph(data, mode) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            const svg = d3.select('#graph-container').append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g');

            const zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            document.getElementById('zoom-in').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 1.5);
            });

            document.getElementById('zoom-out').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 0.75);
            });

            document.getElementById('reset-zoom').addEventListener('click', () => {
                svg.transition().call(zoom.transform, d3.zoomIdentity);
            });

            const simulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.links).id(d => d.id).distance(150))
                .force('charge', d3.forceManyBody().strength(-500))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(50));

            const link = g.append('g')
                .selectAll('line')
                .data(data.links)
                .enter()
                .append('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 1.5);

            const node = g.append('g')
                .selectAll('g')
                .data(data.nodes)
                .enter()
                .append('g')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            node.append('rect')
                .filter(d => d.type === 'entity')
                .attr('width', 100)
                .attr('height', 30)
                .attr('x', -50)
                .attr('y', -15)
                .attr('fill', '#69b3a2')
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .attr('rx', 5)
                .attr('ry', 5);

            node.append('circle')
                .filter(d => d.type === 'literal_group')
                .attr('r', d => 15 + 10 * (d.properties ? d.properties.length : 0))
                .attr('fill', '#ff9e40')
                .attr('stroke', '#fff')
                .attr('stroke-width', 2);

            node.append('text')
                .text(d => d.type === 'literal_group' ? `${d.entity}` : d.id)
                .attr('text-anchor', 'middle')
                .attr('dy', d => d.type === 'literal_group' ? '-20' : '5')
                .attr('font-size', '12px')
                .attr('fill', '#333');

            if (mode === 'cartouches') {
                data.nodes.forEach(node => {
                    if (node.type === 'literal_group' && node.properties) {
                        const group = g.append('g').attr('class', 'literal-group');
                        node.properties.forEach((prop, i) => {
                            group.append('text')
                                .text(`${prop.property}: ${prop.value}`)
                                .attr('x', node.x)
                                .attr('y', node.y + 20 + i * 15)
                                .attr('text-anchor', 'middle')
                                .attr('font-size', '10px')
                                .attr('fill', '#555');
                        });
                    }
                });
            }

            const linkLabels = g.append('g')
                .selectAll('text')
                .data(data.links)
                .enter()
                .append('text')
                .text(d => d.label)
                .attr('font-size', '10px')
                .attr('fill', '#666');

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('transform', d => `translate(${d.x},${d.y})`);

                linkLabels
                    .attr('x', d => (d.source.x + d.target.x) / 2)
                    .attr('y', d => (d.source.y + d.target.y) / 2);

                if (mode === 'cartouches') {
                    g.selectAll('.literal-group text')
                        .attr('x', d => {
                            const nodeData = data.nodes.find(n => n.id === d.id + '_props');
                            return nodeData ? nodeData.x : d.x;
                        })
                        .attr('y', (d, i) => {
                            const nodeData = data.nodes.find(n => n.id === d.id + '_props');
                            return nodeData ? nodeData.y + 20 + i * 15 : d.y + 20 + i * 15;
                        });
                }
            });

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }
    </script>
</body>
</html>
